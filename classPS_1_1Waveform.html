<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Waveform: PS::Waveform&lt; TimeContainer, FreqContainer, TransformT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Waveform
   </div>
   <div id="projectbrief">Waveform is a C++ header-only library which represents both the time and the frequency domains of a waveform/signal as a single object, transforming using FFTW automatically when needed.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePS.html">PS</a></li><li class="navelem"><a class="el" href="classPS_1_1Waveform.html">Waveform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPS_1_1Waveform-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PS::Waveform&lt; TimeContainer, FreqContainer, TransformT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classPS_1_1Waveform.html" title="Waveform class: Transform as-needed between time and freq domains. ">Waveform</a> class: Transform as-needed between time and freq domains.  
 <a href="classPS_1_1Waveform.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae7489f08da3ee9f47f97070a6a1015be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7489f08da3ee9f47f97070a6a1015be"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DomainSpecifier</b> { <b>TimeDomain</b>, 
<b>FreqDomain</b>, 
<b>EitherDomain</b>
 }</td></tr>
<tr class="separator:ae7489f08da3ee9f47f97070a6a1015be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42fd7401f467f15f5299cf48f63b651"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42fd7401f467f15f5299cf48f63b651"></a>
typedef TimeContainer::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#af42fd7401f467f15f5299cf48f63b651">TimeT</a></td></tr>
<tr class="memdesc:af42fd7401f467f15f5299cf48f63b651"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the time domain. <br /></td></tr>
<tr class="separator:af42fd7401f467f15f5299cf48f63b651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca087b635e1693671907f0ac717a1e9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca087b635e1693671907f0ac717a1e9d"></a>
typedef FreqContainer::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#aca087b635e1693671907f0ac717a1e9d">FreqT</a></td></tr>
<tr class="memdesc:aca087b635e1693671907f0ac717a1e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the frequency domain. <br /></td></tr>
<tr class="separator:aca087b635e1693671907f0ac717a1e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15f22452e893992d80a09131a5263c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac15f22452e893992d80a09131a5263c0"></a>
typedef std::pair&lt; <a class="el" href="classPS_1_1Waveform.html#af42fd7401f467f15f5299cf48f63b651">TimeT</a>, <a class="el" href="classPS_1_1Waveform.html#aca087b635e1693671907f0ac717a1e9d">FreqT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ac15f22452e893992d80a09131a5263c0">value_type</a></td></tr>
<tr class="memdesc:ac15f22452e893992d80a09131a5263c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "type" of the <a class="el" href="classPS_1_1Waveform.html" title="Waveform class: Transform as-needed between time and freq domains. ">Waveform</a>, inspired by std::map. <br /></td></tr>
<tr class="separator:ac15f22452e893992d80a09131a5263c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24d806b07303e9aa5a2168a396f96fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad24d806b07303e9aa5a2168a396f96fe"></a>
typedef <br class="typebreak" />
TimeContainer::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ad24d806b07303e9aa5a2168a396f96fe">TimeAllocT</a></td></tr>
<tr class="memdesc:ad24d806b07303e9aa5a2168a396f96fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator type of the time domain container. <br /></td></tr>
<tr class="separator:ad24d806b07303e9aa5a2168a396f96fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161c7152f413a98ea422b4cddc35e53a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a161c7152f413a98ea422b4cddc35e53a"></a>
typedef <br class="typebreak" />
FreqContainer::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a161c7152f413a98ea422b4cddc35e53a">FreqAllocT</a></td></tr>
<tr class="memdesc:a161c7152f413a98ea422b4cddc35e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator type of the frequency domain container. <br /></td></tr>
<tr class="separator:a161c7152f413a98ea422b4cddc35e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad597a281d27f0a14a7bbedd1d39e8c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad597a281d27f0a14a7bbedd1d39e8c02"></a>
typedef TimeContainer::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ad597a281d27f0a14a7bbedd1d39e8c02">TimeIterator</a></td></tr>
<tr class="memdesc:ad597a281d27f0a14a7bbedd1d39e8c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type of the time domain container. <br /></td></tr>
<tr class="separator:ad597a281d27f0a14a7bbedd1d39e8c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1525288dfcbcd2f8a685e12549ec262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1525288dfcbcd2f8a685e12549ec262"></a>
typedef FreqContainer::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#aa1525288dfcbcd2f8a685e12549ec262">FreqIterator</a></td></tr>
<tr class="memdesc:aa1525288dfcbcd2f8a685e12549ec262"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type of the frequency domain container. <br /></td></tr>
<tr class="separator:aa1525288dfcbcd2f8a685e12549ec262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e892e44ee65a67899654b82f71536cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e892e44ee65a67899654b82f71536cf"></a>
typedef <br class="typebreak" />
TimeContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a3e892e44ee65a67899654b82f71536cf">TimeConstIterator</a></td></tr>
<tr class="memdesc:a3e892e44ee65a67899654b82f71536cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const iterator type of the time domain container. <br /></td></tr>
<tr class="separator:a3e892e44ee65a67899654b82f71536cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f2e305849e80c6f8ec3890c351538c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39f2e305849e80c6f8ec3890c351538c"></a>
typedef <br class="typebreak" />
FreqContainer::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a39f2e305849e80c6f8ec3890c351538c">FreqConstIterator</a></td></tr>
<tr class="memdesc:a39f2e305849e80c6f8ec3890c351538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const iterator type of the frequency domain container. <br /></td></tr>
<tr class="separator:a39f2e305849e80c6f8ec3890c351538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac075d1a0cc65b6605b1f713d0ef736ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac075d1a0cc65b6605b1f713d0ef736ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ac075d1a0cc65b6605b1f713d0ef736ff">Waveform</a> (const std::size_t count)</td></tr>
<tr class="memdesc:ac075d1a0cc65b6605b1f713d0ef736ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill constructor. <br /></td></tr>
<tr class="separator:ac075d1a0cc65b6605b1f713d0ef736ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc68c0be529cc982e46e4a480d7d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbbc68c0be529cc982e46e4a480d7d53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#abbbc68c0be529cc982e46e4a480d7d53">Waveform</a> (const <a class="el" href="classPS_1_1Waveform.html">Waveform</a> &amp;toCopy)</td></tr>
<tr class="memdesc:abbbc68c0be529cc982e46e4a480d7d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:abbbc68c0be529cc982e46e4a480d7d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9327af152d7242de328967fa65abe66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9327af152d7242de328967fa65abe66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ad9327af152d7242de328967fa65abe66">Waveform</a> (const TimeContainer &amp;toCopy)</td></tr>
<tr class="memdesc:ad9327af152d7242de328967fa65abe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time domain copy constructor. <br /></td></tr>
<tr class="separator:ad9327af152d7242de328967fa65abe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5599e9632b91d8e14582ea41faa99ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5599e9632b91d8e14582ea41faa99ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ad5599e9632b91d8e14582ea41faa99ea">Waveform</a> (const FreqContainer &amp;toCopy)</td></tr>
<tr class="memdesc:ad5599e9632b91d8e14582ea41faa99ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency domain copy constructor. <br /></td></tr>
<tr class="separator:ad5599e9632b91d8e14582ea41faa99ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39254337ba7c0f64169d2c2fb28fb1d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39254337ba7c0f64169d2c2fb28fb1d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a39254337ba7c0f64169d2c2fb28fb1d1">~Waveform</a> (void)</td></tr>
<tr class="memdesc:a39254337ba7c0f64169d2c2fb28fb1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a39254337ba7c0f64169d2c2fb28fb1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20159d1bca7a43113522f0e6e734e99d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a20159d1bca7a43113522f0e6e734e99d">GetSize</a> (void)</td></tr>
<tr class="memdesc:a20159d1bca7a43113522f0e6e734e99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the time domain container.  <a href="#a20159d1bca7a43113522f0e6e734e99d">More...</a><br /></td></tr>
<tr class="separator:a20159d1bca7a43113522f0e6e734e99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2d28d275dd85d91c2e34a1e55156b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b2d28d275dd85d91c2e34a1e55156b7"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a5b2d28d275dd85d91c2e34a1e55156b7">size</a> (void)</td></tr>
<tr class="memdesc:a5b2d28d275dd85d91c2e34a1e55156b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the time domain container. <br /></td></tr>
<tr class="separator:a5b2d28d275dd85d91c2e34a1e55156b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc578cdba874e25c3b91d203a3820af9"><td class="memItemLeft" align="right" valign="top">const TimeContainer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#afc578cdba874e25c3b91d203a3820af9">GetConstTimeSeries</a> (void)</td></tr>
<tr class="memdesc:afc578cdba874e25c3b91d203a3820af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant reference to the time domain container.  <a href="#afc578cdba874e25c3b91d203a3820af9">More...</a><br /></td></tr>
<tr class="separator:afc578cdba874e25c3b91d203a3820af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b9c619adffc3ae882dcfa7059588e"><td class="memItemLeft" align="right" valign="top">const FreqContainer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a5d1b9c619adffc3ae882dcfa7059588e">GetConstFreqSpectrum</a> (void)</td></tr>
<tr class="memdesc:a5d1b9c619adffc3ae882dcfa7059588e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant reference to the frequency domain container.  <a href="#a5d1b9c619adffc3ae882dcfa7059588e">More...</a><br /></td></tr>
<tr class="separator:a5d1b9c619adffc3ae882dcfa7059588e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4f1bacf6211dae19efb4747c007983"><td class="memItemLeft" align="right" valign="top">TimeContainer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a7a4f1bacf6211dae19efb4747c007983">GetTimeSeries</a> (void)</td></tr>
<tr class="memdesc:a7a4f1bacf6211dae19efb4747c007983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable reference to the time domain container.  <a href="#a7a4f1bacf6211dae19efb4747c007983">More...</a><br /></td></tr>
<tr class="separator:a7a4f1bacf6211dae19efb4747c007983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c881386e0ef4b148672a34fb76f774"><td class="memItemLeft" align="right" valign="top">FreqContainer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#af7c881386e0ef4b148672a34fb76f774">GetFreqSpectrum</a> (void)</td></tr>
<tr class="memdesc:af7c881386e0ef4b148672a34fb76f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable reference to the frequency domain container.  <a href="#af7c881386e0ef4b148672a34fb76f774">More...</a><br /></td></tr>
<tr class="separator:af7c881386e0ef4b148672a34fb76f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8044666f1fd4de46797ed4ba9c75c42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#ab8044666f1fd4de46797ed4ba9c75c42">ValidateDomain</a> (const DomainSpecifier toValidate)</td></tr>
<tr class="memdesc:ab8044666f1fd4de46797ed4ba9c75c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate and ensure that the specified domain is up-to-date.  <a href="#ab8044666f1fd4de46797ed4ba9c75c42">More...</a><br /></td></tr>
<tr class="separator:ab8044666f1fd4de46797ed4ba9c75c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823676cfddfb117ce92d23fcee91389e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPS_1_1Waveform.html">Waveform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a823676cfddfb117ce92d23fcee91389e">operator=</a> (<a class="el" href="classPS_1_1Waveform.html">Waveform</a> rhs)</td></tr>
<tr class="memdesc:a823676cfddfb117ce92d23fcee91389e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator.  <a href="#a823676cfddfb117ce92d23fcee91389e">More...</a><br /></td></tr>
<tr class="separator:a823676cfddfb117ce92d23fcee91389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a5441b595ae915b36dd22b89e6300b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a36a5441b595ae915b36dd22b89e6300b">Waveform</a> (<a class="el" href="classPS_1_1Waveform.html">Waveform</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a36a5441b595ae915b36dd22b89e6300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor (C++11)  <a href="#a36a5441b595ae915b36dd22b89e6300b">More...</a><br /></td></tr>
<tr class="separator:a36a5441b595ae915b36dd22b89e6300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6930ce77fbdeec54035d3045681a1d29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPS_1_1Waveform.html#a6930ce77fbdeec54035d3045681a1d29">swap</a> (<a class="el" href="classPS_1_1Waveform.html">Waveform</a> &amp;first, <a class="el" href="classPS_1_1Waveform.html">Waveform</a> &amp;second)</td></tr>
<tr class="memdesc:a6930ce77fbdeec54035d3045681a1d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two values without throwing.  <a href="#a6930ce77fbdeec54035d3045681a1d29">More...</a><br /></td></tr>
<tr class="separator:a6930ce77fbdeec54035d3045681a1d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TimeContainer, typename FreqContainer = TimeContainer, typename TransformT = PlaceholderTransformClass&gt;<br />
class PS::Waveform&lt; TimeContainer, FreqContainer, TransformT &gt;</h3>

<p><a class="el" href="classPS_1_1Waveform.html" title="Waveform class: Transform as-needed between time and freq domains. ">Waveform</a> class: Transform as-needed between time and freq domains. </p>
<p>The <a class="el" href="classPS_1_1Waveform.html" title="Waveform class: Transform as-needed between time and freq domains. ">Waveform</a> class allows automatic transform (via FFTW) between time and frequency domains.</p>
<p>Upon instantiation, one domain is made "active", and the other domain will not be calculated until requested.</p>
<p>When one domain is modified, the other domain will be invalidated and must be recalculated upon next request.</p>
<p>After a transform is completed, both domains will be valid until one is modified. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00131">131</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a36a5441b595ae915b36dd22b89e6300b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::<a class="el" href="classPS_1_1Waveform.html">Waveform</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPS_1_1Waveform.html">Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor (C++11) </p>
<p>When rhs is just an rvalue, C++11 can make use of move semantics, instead of copying values from memory to memory, the references are swapped, in the exact same way they were for the copy assignment operator.</p>
<p>This particular function also uses constructor delegation, a feature which is not present for all compiler's implementations of C++11. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00557">557</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d1b9c619adffc3ae882dcfa7059588e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FreqContainer&amp; <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::GetConstFreqSpectrum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant reference to the frequency domain container. </p>
<p>Pass "EitherDomain" because domain will not be modified. Unfortunately the const keyword cannot be used here, because ValidateDomain(...) could modify the class.</p>
<p>If enough thought went into it, there could be a way to separate these cases and use overloading between the non-const and const member methods. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00300">300</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc578cdba874e25c3b91d203a3820af9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TimeContainer&amp; <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::GetConstTimeSeries </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns constant reference to the time domain container. </p>
<p>Pass "EitherDomain" because domain will not be modified.</p>
<p>Unfortunately the const keyword cannot be used here, because ValidateDomain(...) could modify the class.</p>
<p>If enough thought went into it, there could be a way to separate these cases and use overloading between the non-const and const member methods. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00285">285</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7c881386e0ef4b148672a34fb76f774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FreqContainer&amp; <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::GetFreqSpectrum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns mutable reference to the frequency domain container. </p>
<p>If the frequency domain is not valid, the forward transform will automatically calculate the appropriate values behind the scenes, given the valid time domain; returns when complete. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00322">322</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20159d1bca7a43113522f0e6e734e99d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::GetSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the time domain container. </p>
<p>&lt;This function seems redundant and will likely be removed. Use <a class="el" href="classPS_1_1Waveform.html#a5b2d28d275dd85d91c2e34a1e55156b7" title="Returns the size of the time domain container. ">Waveform::size()</a> instead, since it's STL-compliant (though this class is difficult to design 100% in line with the STL idioms)&gt; </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00263">263</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a4f1bacf6211dae19efb4747c007983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TimeContainer&amp; <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::GetTimeSeries </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns mutable reference to the time domain container. </p>
<p>If the time domain is not valid, the inverse/reverse transform will automatically calculate the appropriate values behind the scenes, given the valid frequency domain; returns when complete. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00311">311</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a823676cfddfb117ce92d23fcee91389e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPS_1_1Waveform.html">Waveform</a>&amp; <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPS_1_1Waveform.html">Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assignment operator. </p>
<p>We need to make sure that copy assignment is without errors, and we can do that using the copy-and-swap idiom.</p>
<p>The values of the lhs and rhs are swapped, not even requiring a check for self-assignment.</p>
<p>Because the operator accepts rhs by value (and mutable), once inside the function rhs is an rvalue, which means that after the two are swapped, the swapped-away object is a temporary rvalue at the end of the scope, destroyed just as the previous value of rhs is returned as "*this", so there is no opportunity for something to throw after the old value was destroyed.</p>
<p>No need to worry about explicit calls to delete/ delete [], and the compiler can basically optimize away the entire transaction using Return Value Optimization (RVO) </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00539">539</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8044666f1fd4de46797ed4ba9c75c42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classPS_1_1Waveform.html">PS::Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt;::ValidateDomain </td>
          <td>(</td>
          <td class="paramtype">const DomainSpecifier&#160;</td>
          <td class="paramname"><em>toValidate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate and ensure that the specified domain is up-to-date. </p>
<p>This function is responsible for properly performing transforms based on which domain(s) are valid as well as the domain which was requested by the programmer.</p>
<p>As a reminder, DomainSpecifier is an enumeration which can be set to one of 3 unique values: TimeDomain, FreqDomain, EitherDomain.</p>
<p>The variable validDomain_ maintains the current state of the system. Each of the values of validDomain_ and their meaning are described below: </p><pre class="fragment">TimeDomain      the time domain array timeSeries_ is valid,
                while the contents of freqSpectrum_ should be
                assumed to be out of date / invalid.

FreqDomain      the freq domain array freqSpectrum_ is valid,
                while the contents of timeSeries_ should be
                assumed to be out of date / invalid.

EitherDomain    this has to meanings, both of which ultimately
                can be treated the same way:
                    1:  The last domain requested was done so
                        using one of the "Const" accessor
                        functions, so both of the domain arrays
                        may be read and modified from this
                        state.
                    2:  The Waveform was just constructed and
                        neither of the domain arrays contain
                        "useful" (useful to the user)
                        information. This means that either of
                        the domain arrays may be written to
                        without worrying about the validity of
                        the other domain. However, this also
                        means that neither of the domain arrays
                        can be read to provide valid data, but
                        since the user just initialized the
                        object they should be aware in any
                        circumstance that the arrays contain
                        only garbage.
</pre><p>The function parameter toValidate can take on those same three values, this time with slightly different meanings: </p><pre class="fragment">TimeDomain      the time domain array was requested and
                transforms should be performed as needed in
                order to validate the domain.

FreqDomain      the freq domain array was requested and
                transforms should be performed as needed in
                order to validate the domain.

EitherDomain    the request for one of the domain arrays was
                of the "Const" variety, so no matter which
                domain the user wanted, both domain arrays
                will be valid after the call. Using
                EitherDomain like this allows the
                implementation to be much simpler.
</pre><p>Because this is the core mechanism of the library, it's important to note that the use of EitherDomain like this is fundamentally reliant on the transform class used for the <a class="el" href="classPS_1_1Waveform.html" title="Waveform class: Transform as-needed between time and freq domains. ">Waveform</a> classes' template parameter TransformT <em>providing two functions which (along with the dataset) form a group (by the definition of group theory)</em>. This means that the transform <img class="formulaInl" alt="$\mathcal{F}$" src="form_0.png"/> and its inverse <img class="formulaInl" alt="$\mathcal{F}^{-1}$" src="form_1.png"/> must be unitary &ndash; that is, they must satisfy the composition criteria</p>
<p><img class="formulaInl" alt="$\mathcal{F}^{-1} \circ \mathcal{F} (x) = id (x)$" src="form_2.png"/></p>
<p>(which is of course the definition of an inverse function!)</p>
<p>This may seem obvious given the mathematical definition of, say, the Fourier transform, but one of the most popular implementations, FFTW3 (<a href="http://www.fftw.org">http://www.fftw.org</a>), does not provide real-to-complex forward- and inverse-transform functions which are true inverses of the other &ndash; the inverse transform of the "...dft_r2c_1d" transform function is the "...dft_c2r_1d" function which results in a scaled inverse. These transforms could be called "scaled unitary" or, but must be rescaled in order to function properly in this library.</p>
<p>You can use transforms which are involutary functions (such as the Laplace transform) by defining both "exec_transform()" and "exec_inverse_transform()" (both are required functions of a compatible TransformT class) to simply call the same function for both. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00450">450</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a6930ce77fbdeec54035d3045681a1d29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeContainer , typename FreqContainer  = TimeContainer, typename TransformT  = PlaceholderTransformClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPS_1_1Waveform.html">Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPS_1_1Waveform.html">Waveform</a>&lt; TimeContainer, FreqContainer, TransformT &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two values without throwing. </p>
<p>Because timeSeries_ and freqSpectrum_ are large container objects, there's a good chance that an overloaded swap function was written for them.</p>
<p>In the event that swap was not specialized for one of the member object types, we bring std::swap into the scope so that way all swap functions may be found using unqualified lookup.</p>
<p>This is necessary for the overloads to work. The concept is coined "Argument-Dependant Lookup", or ADL.</p>
<p>None of the swaps should throw, but the order in which the member objects are swapped could still matter.</p>
<p>It's also possible that the transform_ object doesn't need to have any state of its own and only wrap functions, but I'm not sure if there is an easy way to attempt that. </p>

<p>Definition at line <a class="el" href="Waveform_8hpp_source.html#l00500">500</a> of file <a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Waveform_8hpp_source.html">Waveform.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 13 2014 14:43:55 for Waveform by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
